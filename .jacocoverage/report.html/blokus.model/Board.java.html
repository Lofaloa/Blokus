<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Board.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;47923_Blokus&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">blokus.model</a> &gt; <span class="el_source">Board.java</span></div><h1>Board.java</h1><pre class="source lang-java linenums">package blokus.model;

import blokus.exception.ModelException;
import java.util.Arrays;
import static java.util.Objects.requireNonNull;

/**
 * Represents the board of &lt;i&gt;Blokus&lt;/i&gt;.
 *
 * @author Logan Farci (47923)
 */
public class Board {

    /**
     * Is the size of a board.
     */
    public static final int SIZE = 20;

    private Piece[][] squares;

    /**
     * Initializes this board with a 20 by 20 empty grid of squares.
     */
<span class="fc" id="L24">    Board() {</span>
<span class="fc" id="L25">        this.squares = new Piece[SIZE][SIZE];</span>
<span class="fc" id="L26">    }</span>

    /**
     * Makes a copy of the given board.
     *
     * @param board is the board to copy.
     */
<span class="fc" id="L33">    Board(Board board) {</span>
<span class="fc" id="L34">        this.squares = board.getSquares();</span>
<span class="fc" id="L35">    }</span>

    /**
     * Gets the squares of this board.
     *
     * @return the squares of this board.
     */
    Piece[][] getSquares() {
<span class="fc" id="L43">        return squares;</span>
    }

    /**
     * Gets the square at the given position.
     *
     * @param row is the row of the square.
     * @param column is the column of the square.
     * @return the square the given position.
     */
    Piece getPieceAt(int row, int column) {
<span class="pc bpc" id="L54" title="1 of 2 branches missed.">        if (!contains(row, column)) {</span>
<span class="nc" id="L55">            throw new ModelException(&quot;Square at position row &quot;</span>
                    + row + &quot;, &quot; + column + &quot; is out of the board bounds.&quot;);
        }
<span class="fc" id="L58">        return squares[row][column];</span>
    }

    /**
     * Gets the color of this board at the given position.
     *
     * @param row is the row of the square.
     * @param column is the column of the square.
     * @return the color of this board at the given position. &lt;code&gt;null&lt;/code&gt;
     * is returned if the board is empty at thee given position.
     */
    public BlokusColor getColorAt(int row, int column) {
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">        if (!contains(row, column)) {</span>
<span class="nc" id="L71">            throw new IllegalArgumentException(&quot;Square at position row &quot;</span>
                    + row + &quot;, &quot; + column + &quot; is out of the board bounds.&quot;);
        }
<span class="fc bfc" id="L74" title="All 2 branches covered.">        if (isEmptyAt(row, column)) {</span>
<span class="fc" id="L75">            return null;</span>
        } else {
<span class="fc" id="L77">            return getPieceAt(row, column).getColor();</span>
        }
    }

    /**
     * Tells if the given square is in this board bounds.
     *
     * @param row is the row of the square to test.
     * @param column is the column of the square to test.
     * @return true if the given square is in the board bounds.
     */
    public boolean contains(int row, int column) {
<span class="fc bfc" id="L89" title="All 8 branches covered.">        return 0 &lt;= row &amp;&amp; row &lt; SIZE &amp;&amp; 0 &lt;= column &amp;&amp; column &lt; SIZE;</span>
    }

    /**
     * Tells if the given position is a corner of this board.
     *
     * @param row is the row of the position.
     * @param column is the column of the position.
     * @return true if the given position is a corner.
     */
    boolean isCorner(int row, int column) {
<span class="fc" id="L100">        requireValidSquare(row, column);</span>
<span class="pc bpc" id="L101" title="1 of 16 branches missed.">        return row == 0 &amp;&amp; column == 0</span>
                || row == 0 &amp;&amp; column == SIZE - 1
                || row == SIZE - 1 &amp;&amp; column == 0
                || row == SIZE - 1 &amp;&amp; column == SIZE - 1;
    }

    /**
     * Tells if the given square is free. A free square does not contains a
     * piece.
     *
     * @param row is the row of the square to test.
     * @param column is the column of the square to test.
     * @return true if the given position is an empty square.
     */
    boolean isEmptyAt(int row, int column) {
<span class="fc bfc" id="L116" title="All 2 branches covered.">        if (!contains(row, column)) {</span>
<span class="fc" id="L117">            throw new IllegalArgumentException(&quot;Position &quot; + row + &quot;, &quot; + column</span>
                    + &quot; is not in the board.&quot;);
        }
<span class="fc bfc" id="L120" title="All 2 branches covered.">        return getPieceAt(row, column) == null;</span>
    }

    /**
     * Tells if the given piece can be placed at the given position.
     *
     * @param piece is the piece to check the placement for.
     * @param row is the row where the piece is to be placed.
     * @param column is the column where the piece is to be placed.
     * @return true if the given piece can placed at the given position.
     */
    boolean hasSpaceFor(Piece piece, int row, int column) {
<span class="fc" id="L132">        requireNonNull(piece, &quot;no given piece.&quot;);</span>
<span class="fc" id="L133">        return piece.getShape().getSquares().stream()</span>
<span class="fc" id="L134">                .map(s -&gt; s.move(row, column))</span>
<span class="fc" id="L135">                .allMatch(s -&gt; isValid(s.getRow(), s.getColumn()));</span>
    }

    /**
     * This if the piece is in a corner of this board
     *
     * @param piece the piece
     * @param row the row of the piece
     * @param column the column of the piece
     * @return true if the piece is in o corner of this board
     */
    boolean isPieceInCorner(Piece piece, int row, int column) {
<span class="fc" id="L147">        requireNonNull(piece, &quot;no piece when determining if it is in a corner&quot;);</span>
<span class="fc" id="L148">        requireValidSquare(row, column);</span>
<span class="fc" id="L149">        return piece.getShape().getSquares().stream()</span>
<span class="fc" id="L150">                .map(s -&gt; s.move(row, column))</span>
<span class="fc" id="L151">                .anyMatch(s -&gt; isCorner(s.getRow(), s.getColumn()));</span>
    }

    /**
     * Tells if this board is empty.
     *
     * @return true if this board does not contain a piece.
     */
    boolean isEmpty() {
<span class="fc bfc" id="L160" title="All 2 branches covered.">        for (int row = 0; row &lt; SIZE; row++) {</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">            for (int column = 0; column &lt; SIZE; column++) {</span>
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">                if (!isEmptyAt(row, column)) {</span>
<span class="nc" id="L163">                    return false;</span>
                }
            }
        }
<span class="fc" id="L167">        return true;</span>
    }

    /**
     * Tells if the given square is valid. A valid square is in this board
     * bounds and free.
     *
     * @param row is the row of the square to test.
     * @param column is the column of the square to test.
     * @return true if the given square is in the board bounds and free.
     */
    boolean isValid(int row, int column) {
<span class="fc bfc" id="L179" title="All 4 branches covered.">        return contains(row, column) &amp;&amp; isEmptyAt(row, column);</span>
    }

    void initialize() {
<span class="fc bfc" id="L183" title="All 2 branches covered.">        for (Piece[] square : squares) {</span>
<span class="fc" id="L184">            Arrays.fill(square, 0, SIZE, null);</span>
        }
<span class="fc" id="L186">    }</span>

    int wrapIndex(int coordinate) {
<span class="pc bpc" id="L189" title="1 of 4 branches missed.">        return coordinate &lt; 0 ? 0 : coordinate &gt; SIZE - 1 ? SIZE - 1 : coordinate;</span>
    }

    /**
     * Tells if the given square is touching another same color square at
     * corner.
     *
     * @param square is the square.
     * @param colorSquare is the color of the square.
     * @return true if the given square is touching another same color square at
     * corner.
     */
    boolean isSquareTouchingSameColorAtCorner(Square square, BlokusColor colorSquare) {
<span class="fc" id="L202">        requireNonNull(square, &quot;isSquareTouchingSameColorAtCorner - no square given&quot;);</span>
<span class="fc" id="L203">        requireNonNull(colorSquare, &quot;isSquareTouchingSameColorAtCorner - no color given&quot;);</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">        return colorSquare == getColorAt(wrapIndex(square.getRow() - 1),</span>
<span class="fc" id="L205">                wrapIndex(square.getColumn() - 1))</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">                || colorSquare == getColorAt(wrapIndex(square.getRow() - 1),</span>
<span class="fc" id="L207">                        wrapIndex(square.getColumn() + 1))</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">                || colorSquare == getColorAt(wrapIndex(square.getRow() + 1),</span>
<span class="fc" id="L209">                        wrapIndex(square.getColumn() - 1))</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">                || colorSquare == getColorAt(wrapIndex(square.getRow() + 1),</span>
<span class="fc" id="L211">                        wrapIndex(square.getColumn() + 1));</span>
    }

    /**
     * Tells if the given piece is touching another same color piece at corner.
     *
     * @param piece is the piece.
     * @return true if the given square is touching another same color square at
     * corner.
     */
    boolean isPieceTouchingSameColorAtCorner(Piece piece, int row, int column) {
<span class="fc" id="L222">        requireNonNull(piece, &quot;isSquareTouchingSameColorAtCorner - no piece given&quot;);</span>
<span class="fc" id="L223">        return piece.getSquares().stream()</span>
<span class="fc" id="L224">                .map(s -&gt; s.move(row, column))</span>
<span class="fc" id="L225">                .anyMatch(s -&gt; isSquareTouchingSameColorAtCorner(s, piece.getColor()));</span>
    }

    /**
     * Tells if the given square is touching another same color square by side.
     *
     * @param square is the square.
     * @param colorSquare is the color of the square.
     * @return true if the given square is touching another same color square by
     * side.
     */
    boolean isSquareTouchingSameColorBySide(Square square, BlokusColor colorSquare) {
<span class="fc" id="L237">        requireNonNull(square, &quot;isSquareTouchingSameColorBySide - no square given&quot;);</span>
<span class="fc" id="L238">        requireNonNull(colorSquare, &quot;isSquareTouchingSameColorBySide - no color given&quot;);</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">        return colorSquare == getColorAt(wrapIndex(square.getRow() - 1), square.getColumn())</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">                || colorSquare == getColorAt(wrapIndex(square.getRow() + 1), square.getColumn())</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">                || colorSquare == getColorAt(square.getRow(), wrapIndex(square.getColumn() + 1))</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">                || colorSquare == getColorAt(square.getRow(), wrapIndex(square.getColumn() + -1));</span>
    }

    /**
     * Tells if the given piece is touching another same color piece by side.
     *
     * @param piece is the piece.
     * @return true if the given square is touching another same color square by
     * side.
     */
    boolean isPieceTouchingSameColorBySide(Piece piece, int row, int column) {
<span class="fc" id="L253">        requireNonNull(piece, &quot;isSquareTouchingSameColorAtCorner - no piece given&quot;);</span>
<span class="fc" id="L254">        return piece.getSquares().stream()</span>
<span class="fc" id="L255">                .map(s -&gt; s.move(row, column))</span>
<span class="fc" id="L256">                .anyMatch(s -&gt; isSquareTouchingSameColorBySide(s, piece.getColor()));</span>
    }

    boolean isColorRestrictedPiece(Piece piece, int row, int column) {
<span class="fc" id="L260">        requireNonNull(piece, &quot;isColorRestrictedPiece - no piece given&quot;);</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">        return !isPieceTouchingSameColorBySide(piece, row, column)</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">                &amp;&amp; isPieceTouchingSameColorAtCorner(piece, row, column);</span>
    }

    /**
     * Makes sure the given square is valid. A valid square is free and is
     * inside the board.
     *
     * @param square is the square to check.
     * @return a valid square.
     */
    void requireValidSquare(int row, int column) throws ModelException {
<span class="fc bfc" id="L273" title="All 2 branches covered.">        if (!contains(row, column)) {</span>
<span class="fc" id="L274">            throw new ModelException(&quot;Square at position row &quot;</span>
                    + row + &quot;, &quot; + column + &quot; is out of the board bounds.&quot;);
        }
<span class="fc bfc" id="L277" title="All 2 branches covered.">        if (!isEmptyAt(row, column)) {</span>
<span class="fc" id="L278">            throw new ModelException(&quot;not a free position at row &quot; + row + &quot;, &quot;</span>
                    + &quot;column &quot; + column + &quot; is occupied by &quot;
<span class="fc" id="L280">                    + getPieceAt(row, column).getColor() + &quot; player.&quot;);</span>
        }
<span class="fc" id="L282">    }</span>

    /**
     * Requires a piece the can be placed at the given position.
     *
     * @param piece is the piece that should be placable.
     * @param row is the row where to place the piece.
     * @param column is the column where to place the piece.
     */
    void requirePlacablePiece(Piece piece, int row, int column) {
<span class="fc bfc" id="L292" title="All 2 branches covered.">        if (!hasSpaceFor(piece, row, column)) {</span>
<span class="fc" id="L293">            throw new ModelException(&quot;piece &quot; + piece.getColor() + &quot; of shape &quot;</span>
<span class="fc" id="L294">                    + piece.getShape() + &quot;cannot be place at row &quot; + row</span>
                    + &quot;, column &quot; + column + &quot;.&quot;);
        }
<span class="fc" id="L297">    }</span>

    /**
     * Adds a given piece square to the given position.
     *
     * @param row is the row where to add the piece square.
     * @param column is the column where to add the piece square.
     * @param piece is the piece to add a square in this board for.
     */
    void addAt(int row, int column, Piece piece) {
<span class="fc" id="L307">        squares[row][column] = piece;</span>
<span class="fc" id="L308">    }</span>

    /**
     * Adds the given piece at the given row and column.
     *
     * @param piece is the piece to addPiece to this board.
     * @param row is the row of the square of destination in this board.
     * @param column is the column of the square of destination in this board.
     */
    void addPiece(Piece piece, int row, int column) {
<span class="fc" id="L318">        requireNonNull(piece, &quot;no piece to add.&quot;);</span>
<span class="fc" id="L319">        requireValidSquare(row, column);</span>
<span class="fc" id="L320">        requirePlacablePiece(piece, row, column);</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">        for (Square square : piece.getSquares()) {</span>
<span class="fc" id="L322">            Square boardSquare = square.move(row, column);</span>
<span class="fc" id="L323">            addAt(boardSquare.getRow(), boardSquare.getColumn(), piece);</span>
<span class="fc" id="L324">        }</span>
<span class="fc" id="L325">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>