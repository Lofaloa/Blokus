<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Blokus.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;47923_Blokus&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">blokus.model</a> &gt; <span class="el_source">Blokus.java</span></div><h1>Blokus.java</h1><pre class="source lang-java linenums">package blokus.model;

import blokus.exception.ModelException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Observable;
import java.util.stream.Collectors;

/**
 * Represents &lt;i&gt;Blokus&lt;/i&gt;.
 *
 * @author Logan Farci (47923)
 */
public class Blokus extends Observable implements Game {

    public final static int NB_PLAYERS = 4;

    private final List&lt;Player&gt; players;
    private final PlayerIterator playerIterator;
    private final Board board;
    private Player currentPlayer;
    private Move currentMove;
    private BlokusState state;

    /**
     * Initializes this game with four players of different colors: blue,
     * yellow, red and green (the players play in this order). The game has
     * initially an empty board.
     */
<span class="fc" id="L32">    public Blokus() {</span>
<span class="fc" id="L33">        this.players = new ArrayList&lt;&gt;(Arrays.asList(new Player(BlokusColor.BLUE),</span>
                new Player(BlokusColor.YELLOW),
                new Player(BlokusColor.RED),
                new Player(BlokusColor.GREEN)));
<span class="fc" id="L37">        this.playerIterator = new PlayerIterator(players);</span>
<span class="fc" id="L38">        this.currentPlayer = players.get(0);</span>
<span class="fc" id="L39">        this.currentMove = null;</span>
<span class="fc" id="L40">        this.board = new Board();</span>
<span class="fc" id="L41">        this.state = BlokusState.FIRST_ROUND;</span>
<span class="fc" id="L42">        currentPlayer.startPlaying();</span>
<span class="fc" id="L43">    }</span>

    @Override
    public void setBotPlayers(int nb_of_bots) {
<span class="fc bfc" id="L47" title="All 4 branches covered.">        if (nb_of_bots &lt; 0 || NB_PLAYERS &lt; nb_of_bots) {</span>
<span class="fc" id="L48">            throw new IllegalArgumentException(nb_of_bots + &quot; is not a valid &quot;</span>
                    + &quot;number of bots, is should be between 0 and 4.&quot;);
        }
<span class="fc bfc" id="L51" title="All 2 branches covered.">        for (int i = 0; i &lt; nb_of_bots; i++) {</span>
<span class="fc" id="L52">            Strategy strategy = new DumbPlayerStrategy(this);</span>
<span class="fc" id="L53">            players.get(i).setStrategy(strategy);</span>
        }
<span class="fc" id="L55">    }</span>

    @Override
    public void initialize() {
<span class="fc bfc" id="L59" title="All 2 branches covered.">        for (Player player : players) {</span>
<span class="fc" id="L60">            player.initialize();</span>
<span class="fc" id="L61">        }</span>
<span class="fc" id="L62">        currentPlayer = players.get(0);</span>
<span class="fc" id="L63">        board.initialize();</span>
<span class="fc" id="L64">        state = BlokusState.FIRST_ROUND;</span>
<span class="fc" id="L65">        currentPlayer.startPlaying();</span>
<span class="fc" id="L66">        notifyView();</span>
<span class="fc" id="L67">    }</span>

    @Override
    public Board getBoard() {
<span class="fc" id="L71">        return new Board(board);</span>
    }

    @Override
    public List&lt;Player&gt; getPlayers() {
<span class="fc" id="L76">        return Collections.unmodifiableList(players);</span>
    }

    @Override
    public Player getCurrentPlayer() {
<span class="fc" id="L81">        return currentPlayer;</span>
    }

    /**
     * Gets the highest score of this game players.
     *
     * @return the highest score of this game players.
     */
    int getHighestScore() {
<span class="fc" id="L90">        return players.stream().mapToInt(p -&gt; p.getScore()).max().getAsInt();</span>
    }

    @Override
    public List&lt;Player&gt; getWinner() {
<span class="fc" id="L95">        int highestScore = getHighestScore();</span>
<span class="fc" id="L96">        List&lt;Player&gt; winners = players.stream()</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">                .filter(p -&gt; p.getScore() == highestScore)</span>
<span class="fc" id="L98">                .collect(Collectors.toList());</span>
<span class="fc" id="L99">        return Collections.unmodifiableList(winners);</span>
    }

    /**
     * Gets this game state.
     *
     * @return this game state.
     */
    BlokusState getState() {
<span class="fc" id="L108">        return state;</span>
    }

    /**
     * Tells if this game is at first round.
     *
     * @return true if this game is at first round.
     */
    boolean isFirstRound() {
<span class="fc bfc" id="L117" title="All 2 branches covered.">        return state == BlokusState.FIRST_ROUND;</span>
    }

    boolean hasAnyPlayerAnStockEmpty() {
<span class="fc" id="L121">        return players.stream().anyMatch(p -&gt; p.getStock().isEmpty());</span>
    }

    boolean areAllPlayersWithDrawn() {
<span class="fc" id="L125">        return players.stream().allMatch(p -&gt; p.isWithdrawn());</span>
    }

    @Override
    public boolean isOver() {
<span class="fc bfc" id="L130" title="All 4 branches covered.">        return hasAnyPlayerAnStockEmpty() || areAllPlayersWithDrawn();</span>
    }

    /**
     * Tells if the first round of this game is over.
     *
     * @return true if the first round of the game is over.
     */
    boolean isFirstRoundOver() {
<span class="fc" id="L139">        return players.stream()</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">                .allMatch(player -&gt; player.getStock().size() == Stock.CAPACITY - 1);</span>
    }

    /**
     * Ends the first round.
     */
    void endFirstRound() {
<span class="fc" id="L147">        this.state = BlokusState.PLAYING;</span>
<span class="fc" id="L148">    }</span>

    /**
     * Requires a placable piece in the board. A placable piece can be placed at
     * the given position in the board.
     *
     * @throws ModelException if the board has not enough place for the piece
     * the current player selected.
     */
    void requirePlacablePiece(int row, int column) {
<span class="nc bnc" id="L158" title="All 2 branches missed.">        if (!board.hasSpaceFor(currentPlayer.getCurrentPiece(), row, column)) {</span>
<span class="nc" id="L159">            throw new ModelException(&quot;The current piece cannot be place at row &quot;</span>
                    + row + &quot;, column &quot; + column + &quot; of the board.&quot;);
        }
<span class="nc" id="L162">    }</span>

    /**
     * Requires a placable corner piece in the board. A placable corner piece
     * can be placed at the given position in the board. It must be in a corner.
     *
     * @throws ModelException if the board has not enough place for the piece
     * the current player selected or if the piece is not in a corner.
     */
    void requirePlacableCornerPiece(int row, int column) {
<span class="nc bnc" id="L172" title="All 2 branches missed.">        if (!board.isPieceInCorner(currentPlayer.getCurrentPiece(), row, column)) {</span>
<span class="nc" id="L173">            throw new ModelException(&quot;The current piece should be placed in a &quot;</span>
                    + &quot;one of the corner of the board.&quot;);
        }
<span class="nc bnc" id="L176" title="All 2 branches missed.">        if (!board.hasSpaceFor(currentPlayer.getCurrentPiece(), row, column)) {</span>
<span class="nc" id="L177">            throw new ModelException(&quot;The current piece cannot be place at row &quot;</span>
                    + row + &quot;, column &quot; + column + &quot; of the board.&quot;);
        }
<span class="nc" id="L180">    }</span>

    @Override
    public void selectCurrentPlayerPiece(Shape shape) {
<span class="fc" id="L184">        currentPlayer.requireNonEmptyStock();</span>
<span class="fc" id="L185">        currentPlayer.selectPiece(shape);</span>
<span class="fc" id="L186">        notifyView();</span>
<span class="fc" id="L187">    }</span>

    @Override
    public void placePiece(int row, int column) {
<span class="fc bfc" id="L191" title="All 2 branches covered.">        if (currentPlayer.getCurrentPiece() == null) {</span>
<span class="fc" id="L192">            throw new IllegalStateException(&quot;The current player has not selected&quot;</span>
                    + &quot; a piece.&quot;);
        }
<span class="fc bfc" id="L195" title="All 2 branches covered.">        if (isFirstRound()) {</span>
<span class="fc" id="L196">            currentMove = new FirstMove(currentPlayer, board, new Square(row, column));</span>
<span class="fc" id="L197">            currentMove.execute();</span>
        } else {
<span class="fc" id="L199">            currentMove = new MainRoundsMove(currentPlayer, board, new Square(row, column));</span>
<span class="fc" id="L200">            currentMove.execute();</span>
        }
<span class="fc bfc" id="L202" title="All 2 branches covered.">        if (isFirstRoundOver()) {</span>
<span class="fc" id="L203">            endFirstRound();</span>
        }
<span class="fc" id="L205">        notifyView();</span>
<span class="fc" id="L206">    }</span>

    @Override
    public void rotateCurrentPlayerPiece() {
<span class="fc bfc" id="L210" title="All 2 branches covered.">        if (!currentPlayer.hasSelectedAPiece()) {</span>
<span class="fc" id="L211">            throw new IllegalStateException(&quot;Player &quot; + currentPlayer.getColor()</span>
                    + &quot; is trying to rotate a piece but has not selected one.&quot;);
        }
<span class="fc" id="L214">        currentPlayer.rotateSelectedPiece();</span>
<span class="fc" id="L215">        notifyView();</span>
<span class="fc" id="L216">    }</span>

    @Override
    public void turnCurrentPlayerPieceOver() {
<span class="fc bfc" id="L220" title="All 2 branches covered.">        if (!currentPlayer.hasSelectedAPiece()) {</span>
<span class="fc" id="L221">            throw new IllegalStateException(&quot;Player &quot; + currentPlayer.getColor()</span>
                    + &quot; is trying to turn a piece over but has not selected one.&quot;);
        }
<span class="fc" id="L224">        currentPlayer.turnSelectedPieceOver();</span>
<span class="fc" id="L225">        notifyView();</span>
<span class="fc" id="L226">    }</span>

    @Override
    public void nextPlayer() {
<span class="fc" id="L230">        currentPlayer.startWaiting();</span>
<span class="fc" id="L231">        currentPlayer = playerIterator.next();</span>
<span class="fc" id="L232">        currentPlayer.startPlaying();</span>
<span class="fc" id="L233">        notifyView();</span>
<span class="fc" id="L234">    }</span>

    void notifyView() {
<span class="fc" id="L237">        setChanged();</span>
<span class="fc" id="L238">        notifyObservers();</span>
<span class="fc" id="L239">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>